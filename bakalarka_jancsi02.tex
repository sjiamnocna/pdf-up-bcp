\documentclass[14pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[paper=a4paper, margin=1.5cm]{geometry}

% FA icons
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{minted}

\usepackage{caption}
\usepackage{subcaption}

\floatplacement{figure}{H}

\DeclareCaptionLabelFormat{numeric}{příloha #2.}
\captionsetup{labelformat=numeric,labelsep=quad}

\usepackage{amsmath}
\usepackage{amssymb}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Bakalářská práce - Využití IT ke generování zadání písemných testů},
    pdfpagemode=FullScreen,
    colorlinks=false,% hyperlinks will be black
    pdfborderstyle={/S/U/W .5}% border style will be underline of width 1pt
}

% citace a jazyk
\usepackage[main=czech, english]{babel}
\usepackage{csquotes}
\usepackage[style=iso-authoryear]{biblatex}
\addbibresource{zdroje.bib}

\begin{document}
	\begin{titlepage}
		\begin{center}
            {
            \centering
            \includegraphics[]{./img/UP_logo_PdF-UP_horizont_cz.pdf}
            }
			
			\vspace{3cm}

            {
                \LARGE
                \textbf{Šimon Janča}\\
                3.\,ročník\\[8mm]
                Obor: Informační technologie a Matematika pro vzdělávání
            }

            \vspace{4cm}
			
			{
			    \textbf{\Huge Využití IT ke generování zadání písemných testů}\\[4mm]
			    \Large
			    Bakalářská práce
			}

            \vfill
            
            {
                Vedoucí práce:
                doc. RNDr. Petr Šaloun, Ph.D.
                \hfill
    			Olomouc \the\year{}
            }
			
		\end{center}
	\end{titlepage}
	% generate table of contents
	\tableofcontents

	\newpage
    \clearpage
    \setcounter{page}{1}
	
	\section{Úvod}
    Cílem této práce je~zmapovat nástroje, které učitelé používají pro~tvorbu písemných prací pro~své~žáky a~definovat potřeby, které v~této souvislosti mohou nastat.
    
    Ve~druhé části popíšu návrh a~implementaci webové aplikace, kterou by~učitelé k~tvorbě různých variant zadání mohli používat.
    
    Zároveň bych rád popsal základní prvky vývoje moderní \textsc{MVC} aplikace a~popsal důvody k~jednotlivým rozhodnutím od~návrhu
    a~výběru technologií, přes plánování pomocí diagramů, až k~její implementaci a spuštění za~použití vybraných technologií.
    
    Pochopitelně nepůjde o~jediný způsob, jak mohou aplikace vzniknout, nicméně by~práce měla být čitelným a~reprodukovatelným postupem vývoje
    a~údržby podobné aplikace.

    \section{Testy, zadání příkladů}
    Testy jsou~jedním z~nejpoužívanějších nástrojů pro~ověření znalostí žáků. V~dnešní době se~testy používají nejen pro~ověření znalostí, ale i~pro~získání zpětné vazby od~žáků.
    
    Testy mohou být psány ručně, nebo mohou být generovány pomocí počítačových nástrojů. V~této kapitole se~budu zabývat problematikou testových úloh, jejich tvorbou a~možnostmi, které nám dnešní technologie nabízí.

    V~rámci této práce se~budu zabývat především písemnými testy, které jsou~používány na~základních a~středních školách. Nicméně většina z~popisovaných technologií je~použitelná i~pro~jiné typy testů. Součástí je~dotazník určený učitelům, který by měl poskytnout informace o~tom, jaké nástroje učitelé v~současnosti používají.

        \subsection{Uzavřené úlohy}

        {
            \centering
            \quote{Když jsou ty~otázky uzavřené, tak už se~na~ně~nedá odpovídat?}\\[2mm]
        }
        
        \textbf{Uzavřené úlohy} jsou~úlohy, které mají předem dané možnosti odpovědí. Žák/student si~při~vyplňování testu vybere jednu z~nich a~tím odpoví na~otázku.

        Řešení takových úloh může~být~méně náročné, jak na~žáka, který může jednodušeji určit (nebo uhodnout) správnou odpověď, tak na~učitele, který nemusí při~hodnocení brát v~potaz různé možnosti odpovědí.

        Nabízí se~tím možnost zápisu do~odpovědních archů a~tím jednodušší vyhodnocení pomocí počítače.

        Bodování takových úloh může být jednoduché, kde~za~každou správnou odpověď přičteme jeden bod, nebo může být složitější, např.~za~každou správnou odpověď jeden bod, kde~navíc za~každou špatnou odpověď bod (nebo část bodu) odečteme, za~nevyplněnou odpověď většinou nedostaneme žádný bod.

        Může jít o~vědomostní otázky s~danými odpověďmi, nebo třeba výběr písmen pro~procvičení správné gramatiky. Také jsou možné různé doplňovačky nebo výběr správného slova do textu. \parencite{rozhlasOUtazky}

        \subsection{Otevřené úlohy}
        \textbf{Otevřené úlohy} jsou~úlohy, které nemají předem dané možnosti odpovědí. Žák/student musí odpověď napsat sám.

        Řešení takových úloh je~náročnější, jak na~žáka, který musí odpověď vymyslet, tak na~učitele, který musí při~hodnocení brát v~potaz různé možnosti odpovědí. Na~druhou stranu to~umožní ocenit i~částečně správné odpovědi nebo vlastní invenci při~řešení, což by~u~uzavřených úloh nebylo možné.

        Může jít o~vypsání odpovědi, nebo třeba výpočet matematického příkladu.
        
        \subsection{V současnosti používané nástroje}
        V~současnosti je~pro~účely tvorby testů používáno několik nástrojů, které se~liší svými možnostmi a~způsobem použití.
        
        Existují některé \textbf{webové stránky}, které nabízejí hotové testy ke~stažení. Ty~potom učitel jen~vytiskne. Na~internetu je~možné najít i~jednotlivé příklady, ze~kterých učitel test sestaví.

        Pokud si~učitel chce test vytvořit, může používat klasické \textbf{tabulkové procesory}, jako je~např.~\textsc{Microsoft Excel} nebo \textsc{Google Sheets}, nebo \textbf{textové procesory}, jako je~např.~\textsc{Microsoft Word} nebo \textsc{Google Docs}.

        V~dnešní době může jednodušeji napsat testy v~\textsc{\latex{u}} nebo ve~formátu \textsc{Markdownu}, které nabízejí jednodušší formátování textu než třeba Word.

        \subsection{Co na tvorbu testů používají učitelé}
        % TODO: dotazník/rozhovory s učiteli

    \section{Vývoj moderních webových aplikací}
    V dnešní době je~webová aplikace první volbou pro~většinu vývojářů. Je~to~způsobeno tím, že~webová aplikace je~dostupná z~jakéhokoliv zařízení, které má~přístup k~internetu a~je~schopné zobrazit webový prohlížeč. Webová aplikace je~také snadno aktualizovatelná a~není potřeba ji instalovat na~každém zařízení zvlášť, stačí pouze otevřít prohlížeč na~dané adrese.
    
    Vývojáři se~také nemusí starat o~kompatibilitu s~různými operačními systémy, protože webový prohlížeč
    je~dostupný na~většině z~nich. Webová aplikace je~také snadno škálovatelná, protože je~uložena na~serveru a~uživatelé se~k~ní připojují.
    
    Navíc je možné díky různým nástrojům vydat aplikaci pro~různé platformy (Android, IOS\dots) z~jednoho zdrojového kódu.\parencite{adobe:webapp}

    Většina dnešních projektů je~tedy vyvíjena jako~MVC webová \textsc{aplikace}. Tím oddělíme logiku aplikace od~jejího zobrazení, což nám umožňuje vývoj funkční části aplikace nezávisle na~uživatelské části a~můžeme třeba pracovat s~různými technologiemi.
    
    Pro obě části existují připravené technologie, které nám usnadní vývoj a~umožní nám vytvořit aplikaci rychleji a~s~menším množstvím chyb.

    \uv{Pro frontend i backend aplikace existuje na webu obrovské množství použitelných materiálů. Ať už jsou to různé grafické prvky nebo serverové komponenty, to vše je už někde nejspíše hotové.}\parencite{itnetworkBestPractices}

        \subsection{Základní statická HTML stránka}
        V roce 1989 vytvořil Tim Berners-Lee první webový prohlížeč a~jazyk HTML. HTML je~zkratka pro~HyperText Markup Language (Hypertextový značkovací jazyk).
        Základem je HTML stránka~--~soubor, který obsahuje textový obsah a~HTML značky, které určují, význam jednotlivých částí obsahu.
        Navíc lze jednotlivé soubory propojit pomocí hypertextových odkazů, které umožňují uživateli kliknutím přecházet z~jedné stránky na~druhou.

        V dnešní době se~HTML stránky skládají z~HTML značek, ale i~CSS stylů, které určují jak má prohlížeč jednotlivé části stránky zobrazit.
        K tomu se přidává i~JavaScript, který umožňuje přidat do~stránky dynamický obsah a~interaktivitu. \parencite{berners:1989:proposal}

        Jednotlivé prvky je možné také označit pomocí identifikátorů a~tříd, které se~používají pro~jejich identifikaci.
        Zatímco tříd může mít prvek více, identifikátor může mít jen jeden. Identifikátor by měl být unikátní. V jedné HTML stránce by se měl vyskytovat jen jednou.
        Třídy se~používají pro~skupiny prvků, které mají stejný vzhled. Prvek může mít více tříd a~kombinovat tak jejich vlastnosti. \parencite{jpw:tridy}

        \subsection{Kompilátor a Interpret}
        Pro~lepší pochopení programování aplikací je~potřeba si~ujasnit rozdíl mezi kompilovaným a~interpretovaným jazykem.

        \textbf{Kompilovaný} jazyk je~jazyk, který se~pomocí tzv.\,překladače (kompilátoru) překládá do~binárního souboru, který obsahuje přímo instrukce,
        které dokáže počítač (procesor) vykonávat. Při~každém spuštění se~do paměti načte binární soubor a~procesor vykonává jeho instrukce.

        \textbf{Interpretovaný} jazyk naopak vykonáván programem, kterému říkáme interpret. Ten čte příkazy a~přímo je~vykonává. To~znamená,
        že~při~každém spuštění se~příkazy překládají znovu. Interpret je program, který musí běžet, zatímco příkazy interpretuje,
        což je taky jeden z~důvodů, proč je~interpretovaný jazyk pomalejší a náročnější na využítí zdrojů, než~kompilovaný.
        
        Interpretování může ale přinést i~výhody. Například je~možné příkazy vykonávat ihned, bez~nutnosti překladu. \parencite{ueda:compiled}
        
        \subsection{Javascript}
        Javascript je skriptovací jazyk, který se~používá k~tvorbě interaktivních webových stránek. Dokáže reagovat na~uživatelské akce,
        jako je~kliknutí, a~tedy na~rozdíl od~statické podoby HTML stránky dokáže měnit obsah podle toho, jak~uživatel se~stránkou pracuje.

        Vznikl v~roce 1995 a~jeho tvůrci jsou Brendan Eich a~společnost Netscape.
        Javascript je~dnes nejrozšířenějším programovacím jazykem na~světě a~používá se~nejen pro~webové stránky,
        ale i~pro~tvorbu nativních aplikací.

        Díky spouštěčům Javascriptu, kterým říkáme Javascriptové enginy, je~možné spouštět Javascript na~různých platformách.
        A tak můžeme Javascript spouštět v~prohlížeči, ale i~na~serveru, a dokonce na~mikrokontrolerech. Jeden jazyk tak zvládne pokrýt
        většinu potřeb, které můžeme při~vývoji aplikací mít.

        Javascript je interpretovaný jazyk, což znamená, že~jednotlivé příkazy se~vykonávají postupně a~při~každém spuštění programu se~překládají.
        To přináší výhodu v~tom, že je možné příkazy vykonávat ihned, ale zároveň to znamená, že~při~každém spuštění se~musí překládat, což může být pomalejší než spouštění kompilovaného binárního souboru.

        Javascript dokáže příkazy zpracovávat synchronně i~asynchronně.
        
        Synchronní zpracování znamená, že~se~příkazy vykonávají postupně, tak jak
        jsou zapsané.
        
        Asynchronní zpracování znamená, že~se~příkazy vykonávají nezávisle na~sobě. To je~užitečné např.~při~načítání dat ze~serveru,
        které může trvat delší dobu. V~tomto případě se~synchronní příkazy vykonávají dál a~když se~data úspěšně načtou, vykoná~se příkaz, který na~ně čeká. \parencite{kantor_javascript}

        \subsection{Typescript}
        Další nevýhodou Javascriptu je, že~není typově bezpečný. To znamená, že~není možné při~překladu zkontrolovat, zda~jsou všechny proměnné
        a~funkce použity správně. To může vést k~chybám, které se~projeví až při~spuštění programu. To je~pro~větší projekty nežádoucí, proto se~používají
        jiné jazyky, které jsou typově bezpečné a~po~kontrole jsou přeloženy (kompilovány, transpilovány) zpět do Javascriptu. Jedním z~nich je~Typescript.
        Kromě typové bezpečnosti přináší Typescript i~další výhody a~optimalizace, které zjednodušují vývoj a~zvyšují výkon aplikace.

        Typescript přidává do~Javascriptu statickou kontrolu typů, což znamená, že~proměnné mají přiřazený datový typ. V~Javascriptu to~normálně není nutné a~dokonce je~možné typy měnit za~běhu programu.
        Díky kontrole typů je~možné provést při překladu kontrolu, zda~jsou všechny proměnné a~funkce použity správně, což redukuje množství chyb.
        Typescript se~kompiluje (transpiluje) zpět do Javascriptu a~je~možné při~vývoji v~Typescriptu použít všechny vlastnosti Javascriptu.\parencite[Get started/TypeScript for the New Programmer]{TypeScript}

        \subsection{DOM - Document Object Model}
        DOM je~objektový model dokumentu, který vytváří prohlížeč na~základě HTML stránky. Jednotlivé HTML značky jsou reprezentovány objekty.
        Před vykreslením stránky v prohlížeči, se~nejprve vytvoří DOM, který obsahuje všechny objekty (HTML prvky), které se~mají zobrazit.
        K~nim pak prohlížeč přiřadí CSS styly a~vykreslí je~na~obrazovku. K~DOMu pak můžeme přistupovat pomocí Javascriptu
        a~můžeme aktivně měnit obsah strány, včetně stylů nebo sledovat uživatelské akce a~na~jejich základě spouštět vlastní funkce.\parencite[2.1.01]{kantor_javascript}
        
        \subsection{HTML s dynamickým obsahem}
        HTML stránky mohou mít i~dynamický obsah. To znamená, že~se~mohou měnit podle toho, jak s~nimi uživatel pracuje.
        Na úrovni serveru se~může generovat HTML stránka, která obsahuje dynamický obsah. V~dnešní době se~častěji používá Javascript,
        nicméně v minulosti se~používaly i~jiné technologie, jako např.~\textsc{PHP (HyperText Preprocessor)}, které na~serveru vygenerovaly HTML stránku.

        To samozřejmě znamenalo, že~při~každé změně obsahu bylo~potřeba znovu kontaktovat server a~stránku znovu načíst do~prohlížeče. Také byla veškerá komunikace omezená na~požadavek od~klienta, server pouze obsluhoval požadavky a~neměl možnost samostatně zaslat zprávu klientovi.
        Tento problém právě adresuje Javascript. Odesílá požadavky na~server a~na~základě odpovědi mění obsah celé nebo části stránky. Díky metodám, jako je~\textsc{AJAX (Asynchronous Javascript And XML)}\parencite{ajax:mdn} je~možné komunikovat se~serverem i~bez~načítání celé stránky.
        Server může - samozřejmě po~povolení ze~strany uživatele - zasílat zprávy na~klientské zařízení i~bez~jeho požadavku díky \textsc{Server-Sent Events}\parencite{sse:mdn} nebo udržovat spojení pomocí \textsc{WebSockets}\parencite{websocket:mdn}. Živý přenos videa nebo internetové hovory jsou~příkladem použití WebSockets.

        To~znamená, že~když např.~uživatel klikne na~tlačítko, nemusí se~stránka znovu načítat celá, pouze se~načtou data ze~serveru
        a~přidají se~do~stránky. To~je~mnohem rychlejší a~příjemnější pro~uživatele.

        

        \subsection{React} je~knihovna pro~tvorbu uživatelského rozhraní. Je~vyvíjena společností Facebook a~je~používána při~vývoji mnoha webových aplikacích.
        Je oblíbená pro svou jednoduchost a~rychlost. Je~také dobře dokumentovaná a~má~velkou komunitu, která ji~podporuje.
        Existuje mnoho nástrojů, které usnadňují vývoj aplikací v~Reactu, jako
        např.~\textsc{Create React App} (někdy se setkáme se zkratkou CRA), nebo \textsc{Vite}.
        Také je spousta již hotových komponent, které můžeme v~naší aplikaci používat.

        Jednotlivé komponenty mohou mít svůj vlastní stav, který se~může měnit. To~umožňuje vytvářet interaktivní aplikace.
        Komponenty mohou být funkcionalní nebo třídní. Funkcionální komponenty jsou jednodušší a~rychlejší na~vytvoření.
        Třídní komponenty jsou složitější, ale umožňují využít všech výhod Reactu. Funkcionální komponenty mohou využívat tzv.~\textsc{React Hooks}, k~dosažení podobné funkcionality, nicméně třídní komponenty jsou stále podporovány a~mohou být použity.
        Navíc \textsc{React Hooks} jsou stále ve~vývoji a~mohou se~změnit.

        Nejnáročnější operace na~výpočetní výkon je~vykreslování webu a~změn v~něm. Tedy změny v~klasickém DOMu.

        React je~díky využití Virtuálního DOMu velice rychlý. Virtuální DOM je~kopie DOMu, která se~používá pro~porovnání změn.
        To~umožňuje aplikaci rozpoznat, kdy je potřeba DOM upravit a~kdy ne. Zamezíme tak zbytečným operacím a~zvýšíme výkon aplikace. \parencite{elrom2021react}

        Komponenty mohou obsahovat i~další komponenty. Tomu říkáme \textsc{zanořování} nebo anglicky \textsc{nesting}. To~umožňuje vytvářet složitější komponenty s~více prvky.
        Při použití \href{https://react.dev/reference/react/createElement}{\texttt{React.createElement} (viz. dokumentace)} by~takový kód byl složitě čitelný. I~proto máme k~dispozici \textbf{JSX}.
        
        \textbf{JSX (Javascript XML)} je~rozšíření jazyka Javascript, které umožňuje využívat zápisu komponent jako v~HTML kódu. Jednotlivé prvky jsou tzv.~komponenty, které se~při~překladu přepisují na~\texttt{React.createElement} a~vykreslují se~do~HTML. To~umožňuje jednodušší tvorbu komponent. \parencite{reactJSX}

        Rozdíl práce na~tvorbě komponent za~použití \texttt{React.createElement}, resp.~\texttt{JSX} je~vidět v~kódu~\ref{JSXcomponent}.
        \begin{figure}
            \begin{subfigure}[b]{0.45\linewidth}
                \begin{minted}[fontsize=\footnotesize,framesep=2mm]{js}
    function ComponentA({ name }) {
        return React.createElement(
            // typ prvku
            'h1',
            // atributy
            { className: 'greeting' },
            // textový obsah
            'Hello World!'
        );
    }
                \end{minted}
                \caption{použití React.createElement}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.45\linewidth}
                \begin{minted}[fontsize=\footnotesize,framesep=2mm]{js}
    const App = () => {
        return (
            <h1 className="greeting">Hello World!</h1>
        );
    }
                \end{minted}
                \vspace{1cm}
                \caption{použití JSX}
            \end{subfigure}
            \label{JSXcomponent}
            \caption{Rozdíl použití React vs.~JSX}
        \end{figure}

        \textbf{Vite} je~nástroj pro~rychlé nastartování projektu v~Reactu ale~i~v~Javascriptu, Typescriptu, Vue a dalších frameworků. Je~vyvíjen společností \textsc{Vue.js}, která je~známá díky svému frameworku \textsc{Vue.js}, který je~Reactu podobný.
        
        \textsc{Vite} také zrychluje spouštění aplikace a~nastavuje tzv.~\textsc{hot reload}, což znamená, že~se~při~každé změně kódu \textsc{frontendu} aplikace v~prohlížeči automaticky načte znovu, bez~nutnosti manipulace s~prohlížečem.
        Vite údajně také zrychluje sestavení modulů více než jiné nástroje.\parencite{vitejs}
        
        \subsection{Client-Server}
        Vývoj webových aplikací je~založen na~modelu klient-server.
        
        \textbf{Server} je~počítač, který poskytuje služby klientovi. V~případě webové aplikace je~to~server, který poskytuje HTML stránku, styly a~skripty.
        Taky posléze poskytuje data, která se~do~ní načítají a~ovlivňují její obsah.

        \textbf{Klient} je~počítač, který služby serveru využívá. V~případě webové aplikace je~to~webový prohlížeč, který zobrazuje HTML stránku.
        V~případě mobilní aplikace je to~aplikace, která se~spouští na~mobilním zařízení a~komunikuje se~serverem. Např.~messengery, sociální sítě. \parencite{ClientServer}
        
        \textbf{Klient} může být webový prohlížeč, ale i~jiná, např. mobilní aplikace, která posílá požadavky a~data na~server.

        \subsection{Webová služba, webový server}
        Webová služba je~program, který běží na~serveru a~poskytuje data klientovi. Na serveru může běžet více webových služeb, rozlišují se portem, na~kterém běží. Např.~webová služba HTTP, která poskytuje webová data a~soubory bude běžet na~portu~80, resp.~443 pro~HTTPS. Další služby mohou být např.~emailová služba SMTP (\textsc{Simple Mail Transfer Protocol}), která poběží nejčastěji na~portu~25 a další.
        
        Služby \uv{naslouchají} na svých portech a~přijímají požadavky od~klientů. K~jednotlivým serverům se~přistupuje pomocí IP adresy a~portu, na~kterém služba běží. \parencite{webserver:mdn}

        \subsection{DNS - Domain Name System}
        DNS je~zkratka pro~\textsc{Domain Name System}, někdy \textsc{Domain Name Server}. Je~to~systém, který překládá doménová jména na~IP adresy. To~umožňuje, aby~uživatelé používali lidem čitelná doménová jména namísto \textsc{IP~adres} cílového serveru, které jsou pro~uživatele těžko zapamatovatelné.
        
        Bez DNS by~se~oblíbený český vyhledávač \texttt{Seznam.cz} proměnil ve~směsici čísel \texttt{77.75.79.222}, což~by~uživatel moc neocenil. To~samé by~platilo i~pro~ostatní weby.

        \textsc{Doménové jméno} je~složeno ze~tří částí. První část je~\textsc{subdoména}, která je~volitelná. Druhou částí je~\textsc{doména} (2.\,řádu), která je~povinná a~třetí část je~\textsc{doménová přípona} (TLD, doména nejvyššího řádu), která je~také povinná. TLD mohou být např.~\texttt{.com}, \texttt{.cz}, \texttt{.eu}, \texttt{.org}. Doménové jméno je~v~procesu \textbf{DNS resolve} přeloženo zpět na \textsc{IP adresu}. \parencite{tld:mdn}
        
        \begin{figure}
            \centering
            \begin{tabular}{l l l l l}
                \textcolor{red}{\texttt{protokol}} &
                \textcolor{blue}{\texttt{subdoména}} &
                \textcolor{green}{\texttt{doména}} &
                \textcolor{orange}{\texttt{TLD}} &
                \textcolor{purple}{\texttt{?query}}\\

                \textcolor{red}{\texttt{https}}:// &
                \textcolor{blue}{\texttt{robot}} &
                . \textcolor{green}{\texttt{killermachine}} &
                . \textcolor{orange}{\texttt{com}} &
                / \textcolor{purple}{\texttt{?znicitlidstvo=false\&parametr=42}}
                
            \end{tabular}
            \label{slozeni-uri}
            \caption{Složky URI}
        \end{figure}

        \textbf{DNS Resolve} je~proces překladu doménového jména na~IP adresu. Když si~uživatel vyžádá nějaké doménové jméno, prohlížeč se~připojí k~\textsc{DNS} a~požádá ho o~překlad doménového jména na~IP adresu. \textsc{DNS} odpoví IP adresou, kterou prohlížeč použije pro~navázání spojení se~serverem.

        Když~zadáme do~prohlížeče doménové jméno, prohlížeč se~pokusí najít \textsc{IP~adresu} v~DNS cache, kam si~ukládá již navštívené weby. Pokud adresu nenajde, připojí~se k~nejbližšímu DNS serveru a~požádá jej o~překlad doménového jména na~IP adresu. DNS odpoví IP adresou, kterou prohlížeč použije pro~navázání spojení se~serverem.

        Nejbližší \textsc{DNS} bývá poskytovatel internetu, který si~udržuje \textsc{DNS-cache}, kde~jsou uloženy \textsc{IP} adresy pro~servery, na~které v~minulosti zákazníci přistupovali. Pokud~tedy záznamy ještě nejsou v~\textsc{DNS cache} prohlížeče, zeptá se~prohlížeč poskytovatele (dále \textsc{ISP}), resp.~zašle požadavek na~adresu nastaveného \textsc{DNS}. Pokud ani~potom záznamy v~\textsc{cache} nezíská, požádá o~ně~postupně nadřazený \textsc{DNS}, správce národní domény (\textbf{CZ.NIC}) a~kořenový DNS server.

        \textbf{DNS Záznamy} může upravovat vlastník domény prostřednictvím \textsc{doménového registrátora}. To~umožňuje přesměrovat doménu na~jiný server, nebo~přidat další informace, jako např.~\textsc{TXT} záznamy, které se~používají pro~ověření domény pro~e-mailové servery.\parencite{dns:mdn}

        \subsection{Webový server}
        Webový server se~stará o~odpovědi na požadavky, většinou přicházející na~port 443 (\textsc{HTTPS}), dříve port 80 (\textsc{HTTP}).

        Server dostane požadavek ve~formě URL (\textsc{Uniform Resource Locator}, někdy taky \textsc{Uniform Resource Identifier}), která obsahuje cestu k~požadovanému zdroji (souboru/službě).

        Webový server už~neslouží pouze k~poskytování statických souborů, ale i~k~poskytování dynamických dat.

        Může například zajistit, že~se~před odesláním soubor na~serveru zpracuje (např. pomocí PHP) a~do~něj se~vloží aktuální data, nebo před odesláním provést kompresi dat, což uspoří mobilní data a~klient, který přistupuje přes mobilní síť, vám bude vděčný. Na~straně klienta se~pak data rozbalí a~zobrazí.

        Webový server je~také zodpovědný za~směrování doménových jmen ke~konkrétním datům na~daném serveru. To~znamená, že~na~jednom serveru může běžet více webových služeb na~různých doménách.
        Pomocí metody~\textsc{Proxy~pass} můžeme také přesměrovat celý provoz domény na jiný port (např.~na~naši aplikaci). \parencite{webserver:mdn}

        Příkladem webového serveru může být \textbf{Apache}, \textbf{Nginx}, \textbf{Lighttpd}, \textbf{Caddy} nebo \textbf{IIS}\dots

        
        \subsection{MVC - Model View Controller}
        Nejvýznamnějším bodem vývoje bylo rozšíření architektury MVC. MVC je~zkratka pro~\textbf{Model View Controller}.
        Podle této architektury oddělujeme logiku aplikace od~jejího zobrazení. To~umožňuje vývoj funkční části aplikace nezávisle na~jejím zobrazení.

        Díky tomu můžeme mít jednu aplikaci, která bude mít různé zobrazení, ale čerpá pouze z~jednoho zdroje. Např.~webovou stránku, mobilní aplikaci a~desktopovou aplikaci.

        Má tři složky; \textbf{Model}, který se~stará o~manipulaci s~daty, \textbf{Controller}, který říká \textbf{Modelu}, co~má~dělat
        a~\textbf{View}, který se~stará o~výsledné zobrazení dat.

        Také to~umožňuje vývoj aplikace týmem vývojářů, kde každý tým může pracovat na~jiné části aplikace. \parencite{MVC}

        \subsection{Frontend, Backend}
        Aplikace se~díky architektuře \textsc{MVC} běžně dělí na~\textbf{frontend} a~\textbf{backend}, které pracují spolu, ale jsou oddělené.

        \textbf{Frontend} je~část aplikace, kterou vidí uživatel. Může to být např.~prostřednictvím prohlížeče. Stará se~o zobrazení (\textbf{View}) a~interakci s~uživatelem (\textbf{Controller}) a~komunikuje s~\textbf{backendem}, zejména pomocí asynchronních požadavků na~server. Je~napsán většinou v~HTML, CSS a~Javascriptu.

        \textbf{Backend} je~část aplikace, která běží na~serveru a~zpracovává nebo~poskytuje data \textbf{frontendu}. Spolupracuje s~databází (\textbf{Model}em), souborovým systémem a~dalšími službami, které jsou potřeba pro~správné fungování aplikace. \textbf{Backend} může být napsán v~různých jazycích, např.~PHP, Java, C\#, Go, Javascript, C++\dots

        \subsection{JSON - Javascript Object Notation}
        \textsc{JSON}~je~formát pro~výměnu dat. Je~to~textový formát, to znamená, že~je~čitelný pro~člověka i~stroj. Používá se~ke~strukturovanému ukládání a~přenosu dat. Dříve byl~hojně využíván formát XML, který je~podobný struktuře HTML. Ostatně XML stále používá spousta aplikací, zejména aplikace státní správy.

        Formát JSON je~podobný zápisu objektů v~Javascriptu. Obsahuje dvojice klíč-hodnota, které jsou odděleny dvojtečkou. Klíčem je~řetězec a~hodnota může být číselná, řetězcová, logická hodnota, pole nebo objekt.
        
        Práce s~formátem JSON je~pohodlnější než s~formátem XML, protože je~mnohem jednodušší a~čitelnější a~vyžaduje méně kódu, jak na~straně serveru, tak na~straně klienta a~jde~celkově o~úspornější formát.

        \subsection{AJAX - Asynchronous Javascript Request}
        AJAX je~technologie, která umožňuje asynchronní komunikaci mezi frontendem a~backendem.
        To~znamená, že~při~každém požadavku na~server se~stránka nemusí znovu načítat, ale pouze se~načtou data ze~serveru a~přidají se~do~stránky.

        Funkce Javascriptu, umožňující asynchronní požadavky na~server, jsou \texttt{fetch} a~\texttt{XMLHttpRequest}.

        AJAX využívá různé HTTP metody, jako GET, POST, PUT, DELETE, PATCH. Tyto metody se~používají pro~odlišení typu požadavku.\parencite{ajax:mdn}

        \subsection{API - Application Interface}
        API je~rozhraní, které umožňuje komunikaci mezi~aplikacemi nebo~i~s~hardware. V~případě webových aplikací se~jedná o~rozhraní mezi frontendem a~backendem. Některá rozhrání umožňují taky komunikaci na~stejném zařízení nebo mezi aplikacemi na~různých zařízeních.
        
        Někerá API jsou veřejná a~umožňují komunikaci s~aplikacemi třetích stran. Např.~API Google Firebase, Microsoft Azure nebo Amazon Web Services umožňují tvorbu tzv.~Serverless aplikací, kde~vývojář tvoří pouze \textsc{frontend} a~o~zbytek se~stará externí služba. To~umožňuje vývojářům se~soustředit na~vývoj aplikace a~nemusí se~starat o~infrastrukturu, která je~potřeba pro~běh aplikace.

        V~dnešní době jsou nejrozšířenější formou API \textsc{REST} a~\textsc{GraphQL}. Pro komunikaci mezi interními aplikacemi se~často používá \textsc{SOAP}. Různý hardware používá k~ovládání např.~\textsc{UART} a~\textsc{SPI}.

        Velice oblíbená je~metoda \textsc{gRPC} (\textsc{Google Remote Procedure Call}), která je~založena na~protokolu HTTP/2 a~používá binární formát \textsc{Protocol Buffers}.
        RPC je~zkratka pro~\textsc{Remote Procedure Call} a~funguje tak, že spouští vzdálené funkce, které jsou na~serveru, což je mnohdy velmi efektivní.
        
        Další výhodou je, že~gRPC zastává deklarativní přístup, kde definujeme služby a~jejich rozhraní a gRPC vygeneruje pomocný kód pro~jazyk, který používáme.\parencite{thenewstackBuildRealWorld}

        \subsection{REST - Representational state transfer}
        \textbf{REST} je~architektura, která definuje způsob komunikace mezi klientem a~serverem. V dnešní době je~díky své jednoduchosti a~rozšířenosti nejčastěji používanou architekturou pro~tvorbu webových rozhrání. Jednoduchost spočívá zejména v~tom, že~každý \textsc{Endpoint} má~svou~vlastní adresu.
        
        \textsc{REST} je~bezstavový, takže každý požadavek je~nezávislý na~předchozím, server si~neukládá data v~závislosti na~připojeném klientovi. To~umožňuje jednodušší testování a~ladění aplikace. Také to~ale~přináší některé výzvy a~omezení, které je~potřeba řešit. Proto je doporučeno omezit využití ukládání dat vázaných na~konkrétní relaci, nicméně nástroje typu \texttt{Cookies} nebo \texttt{Session} je~možné využívat.
        
        \textsc{REST} definuje, jaké \textsc{HTTP metody} se~používají pro~komunikaci, a~každé přiděluje určitý význam. Mezi nejčastěji používané metody patří \textbf{GET}, \textbf{POST}, \textbf{PUT}, \textbf{DELETE} a \textbf{PATCH}. Metoda je~uložena v~hlavičce HTTP požadavku.

        Funkce jednotlivých \textsc{HTTP metod} jsou:
        \begin{itemize}
            \item \textbf{GET} slouží pro~získání dat ze~serveru,
            \item \textbf{POST} pro~odeslání dat na~server,
            \item \textbf{PUT} pro~úpravu dat na~serveru,
            \item \textbf{DELETE} slouží pro~smazání dat ze~serveru,
            \item \textbf{PATCH} potom pro~úpravu části dat na~serveru.
        \end{itemize}

        Souhrnně těmto operacím říkáme \textsc{CRUD operace}, což je~zkratka pro~\textbf{Create}, \textbf{Read}, \textbf{Update} a \textbf{Delete}.

        Kromě požadavků \textbf{GET} se v~těle požadavku posílají data v~textové formě, např.~formátu~JSON. 
        V~případě požadavku \textbf{GET} se~data vkládají do URL adresy, nejsou šifrována a~mají limitovanou velikost maximální délkou \textsc{URL adresy}.

        \subsection{GraphQL}
        Naproti \textsc{REST}u má \textsc{GraphQL} pouze jeden \textsc{endpoint}. \textsc{GraphQL} je~jazyk, který umožňuje klientovi specifikovat, jaká data chce klient získat. To~umožňuje získat všechna potřebná data v~jednom požadavku, což může být výhodné, pokud máme pomalé připojení nebo~při~mobilním připojení, kdy chceme co~nejvíce ušetřit data.

        Na~druhou stranu implementace \textsc{GraphQL} je~složitější než \textsc{REST}, protože je~potřeba implementovat \textsc{GraphQL} server, který bude umět zpracovat požadavky od~klienta. Každý kousek informace, který chceme zpřístupnit, navíc musíme specifikovat v~\textsc{GraphQL} schématu a~vytvořit pro~něj tzv.~\textsc{resolver}, který zpracuje požadavek a~vrátí data. To~zároveň vytváří větší zátěž na~serveru, protože musíme pro~každou vyžadovanou položku spustit vlastní funkci, což~je v~případě větších datových objektů a~přístupů do~databáze neefektivní.

        
        \subsection{Zabezpečení}
        Vystavením aplikace na~internetu uvádíme naše API do~nebezpečí útoku a~prolomení zabezpečení. Proto je~potřeba aplikaci zabezpečit a~v~žádném případě nespoléhat na~neprůstřelnost zabezpečení knihoven 3.\,stran, které používáme.
        To~znamená, že~je~potřeba zabezpečit API, databázi a~další služby, které aplikace využívá. Je~tedy nutné zvážit např. jaké služby potřebujeme veřejně dostupné a~zbytek zablokovat pomocí firewallu, a~ke~službám, ke~kterým potřebujeme soukromý přístup, přistupovat pomocí tzv.~SSH tunelu. Taky je~nutné udržovat systémy aktuální.
        
        Z~hlediska zabezpečení webové aplikace pak~hovoříme o~dvou základních bodech. \textbf{Autentikace} a~\textbf{autorizace}.

            \subsubsection{Autentikace (Authentication)}
            \textbf{Autentikace} je~proces ověření identity uživatele. To~znamená, že~uživatel musí dokázat, že~je~tím, za~koho se~vydává. To~se~dělá pomocí hesla nebo pomocí certifikátu, který uživatel má.
            
            V~případě \textsc{API} se~jedná o~ověření, že~požadavek přišel z~naší aplikace a~ne z~jiného zdroje, např.~od~útočníka. Na~to~existují různé metody, např.~využití \textsc{JWT}.
            
            Do~frontendu aplikace vložíme dvojici tajných údajů, které backendu řeknou, že~jde skutečně o~naši aplikaci, resp.~o~jinou aplikaci, která má~k~backendu přístup. Taky můžeme přístup pomocí tajných údajů omezit na~konkrétní IP adresu, ze~které se~připojuje, nebo jakékoliv další informace, které jsou stálé a~můžeme je~vyčíst z~přicházejícího požadavku.

            Při autentikaci aplikace je~důležité kontrolovat také jestli~požadavek přišel z~povolené IP~adresy, byl vytvořen naší aplikací na~našem webu, klientovu \textsc{IP~adresu} a~další informace, které by~mohly odhalit nepovolený přístup. Při~každém požadavku je~pak potřeba ověřit, že~\textsc{token} nebyl změněn a~přichází stále z~naší aplikace. \parencite{graham2021ethical}
            
            \subsubsection{Autorizace (Authorization)}
            Autorizace je~proces ověření oprávnění uživatele. To~znamená, že~uživatel musí dokázat, že~má~povolení k~provedení akce.
            To~je možné ověřit pomocí rolí, které uživatel má, nebo pomocí oprávnění k~operacím s~daným zdrojem.

            Třeba, zda je~uživatel autorem příspěvku a~tedy jej může upravit, pozměnit nebo smazat. \parencite{graham2021ethical}

            \subsubsection{JWT - JSON Web Token}
            Metoda zabezpečení, která se~často používá, je~JWT. Jedná se~o~formát textového řetězce (tokenu), který obsahuje informace o~uživateli a~aktivním stavu aplikace.
            
            Při autentikaci se~vygeneruje \textsc{token} (řetězec znaků), který se~při~každém požadavku na~server posílá v~hlavičce požadavku.
            Data v~tokenu jsou zašifrována a~podepsána privátním šifrovacím klíčem, takže je~nelze, bez~znalosti klíče, změnit. Do~tokenu se~přidávají data, která potřebujeme uchovat nebo je~využíváme na~dodatečnou kontrolu. V~případě změny nebo nepřesnosti v~datech tokenu se~token stává neplatným.
            To~umožňuje ověřit, že~token byl vytvořen serverem a~ne někým jiným. Zároveň v~datech tokenu můžeme mít informace o~uživateli, který je právě přihlášen,
            a~další kontrolní informace, jako např.~čas platnosti tokenu nebo IP adresa, ze~které byl požadavek na vytvoření tokenu prvně odeslán.

            Lze to~vidět na~schématu \ref{model-jwt}.

            \begin{figure}
                \centering
                \includegraphics{img/jwt.jpg}
                \label{model-jwt}
                \caption{Použití JWT v~praxi}
            \end{figure}

            Výhodou je také možnost přenositelnosti. Token může být vytvořen na~jednom serveru a~ověřen na~jiném, který ná k~dispozici daný klíč \parencite{ieee:jwt}. Můžeme tak např.~umožnit jednotné přihlášení v~rámci několika služeb. JWT~není vázán na~symetrické šifrování a~tak se~k~využití přenositelnosti často využívá \textsc{asymetrické šifrování} - dvojice klíčů, kde hlavní server má \textsc{privátní klíč} a~ostatní mají \textsc{veřejný klíč} \parencite{miguelgrinbergJSONTokens}.

            Zajímavou možností by~bylo i~využití \textsc{homeomorfního šifrování}, které umožňuje pomocí speciálního klíče provádět operace přímo nad~zašifrovanými daty, aniž bychom je~museli předem dešifrovat. \parencite{homeomorphicEncryption}

        \subsection{Testování}
        Testování je~důležitou součástí vývoje aplikace a~černé svědomí velké části vývojářů. Testování je~časově náročné a~vývojáři se~mu~často vyhýbají, protože je~potřeba vytvořit sadu testů, které pokryjí všechny možné situace, které mohou nastat.
        
        Na~druhou stranu - zejména automatickým - testováním můžeme ušetřit spoustu času, který bychom jinak strávili ručním testováním aplikace. Automatické testování umožňuje vytvořit sadu testů, které můžeme spustit při~každé změně aplikace a~ověřit si~tak, že~aplikace stále funguje správně.
        
        Např.~při~změnách základní funkcionality je~dobré otestovat, že~i~po~změnách fungují stále stejně. Zejména testujeme tzv.~\textbf{čisté funkce}, což jsou funkce, které nemají žádné vedlejší efekty a~vždy vrací stejný výsledek pro~stejný vstup. Takové testování nazýváme \textbf{unit testing}.
        
        V~každém jazyce existují nástroje pro~automatické testování. Např.~v~případě Javascriptu jsou~to~\textbf{Jest}, \textbf{Mocha}, \textbf{Chai} nebo \textbf{Jasmine}. Go~má~vestavěný nástroj pro~testování~\textbf{Go~test}.
        
        Pro~testování React aplikace budu používat \textbf{Jest}. Pro~testování backendu budu používat \textbf{Go~test} \parencite{jestjsTestingReact}.
        
        \subsubsection{Testování API}
        Pro~automatické testování API existují nástroje, které umožní vytvářet požadavky bez~nutnosti mít~hotovou \textsc{frontendovou} část. Mezi nejznámější patří \textbf{Postman}, \textbf{Insomnia} nebo \textbf{Swagger}. Některé navíc nabízejí možnost vytvořit si~sadu automatických testů, které můžeme automaticky spustit při~sestavení aplikace a~ověřit si~tak, že~API stále funguje správně.

        K~tomuto účelu využívám \textsc{Postman}. S~nastaveným testovacím skriptem si~jednoduše ukládám nový \textsc{token} a~při~dalším požadavku ho~posílám v~hlavičce požadavku. Tímto způsobem můžu testovat backend, bez vypínání bezpečnostních opatření.

        \subsubsection{Testování frontendu}
        Pro~testování frontendu budu používat knihovnu \textbf{Jest}, kterou na~testování používá např.~Facebook. Testovat~bude potřeba čisté funkce, ale také komponenty. Komponenty se~testují pomocí snapshotů, které porovnávají vykreslenou komponentu s~předchozí verzí. Pokud se~liší, test selže a~je~potřeba zkontrolovat, zda~je~změna v~pořádku. \parencite{jestjsTestingReact}

        \subsection{Údržba aplikace}
        Údržba aplikace je~důležitá část vývoje. Je~potřeba aplikaci pravidelně aktualizovat a~opravovat chyby, které se~vyskytnou.
        Tedy jde o nejdelší část životního cyklu aplikace. V~této části je~potřeba aplikaci testovat a~opravovat chyby, které se~vyskytnou.
            
            \subsubsection{SDLC - Životní cyklus vývoje software (Software Development Life Cycle)}
            SDLC je~životní cyklus vývoje softwaru. Jedná se~o~soubor procesů, které se~používají při~vývoji softwaru.
            Tyto procesy se~opakují v~kolech, které se~nazývají iterace. V~každé iteraci se~vyvíjí část aplikace, která je~následně testována.
            Vývojáři se~také mohou v~každé iteraci vrátit k~předchozí části a~upravit ji~podle potřeby.
            
            Existuje několik modelů \textsc{SDLC}, které se~liší počtem iterací a~způsobem vývoje. Nejčastěji se~používá model \textsc{Agile},
            který je~založen na~iteracích a~pravidelné komunikaci se~zákazníkem. V~každé iteraci se~vyvíjí část aplikace, která je~následně testována.
            
            Existují ale i~jiné modely vývoje, jako např.~\textsc{Vodopádový}, který je~založen na~jedné iteraci.
            V~té se~vyvíjí celá aplikace a~až poté se~testuje a~nasazuje.
            V~případě chyby je~potřeba se~vrátit na~začátek a~vyvíjet aplikaci znovu.

            \subsubsection{Sledování chyb nahlášených uživateli}
            Pokud uživatel narazí na~chyby v~aplikaci, měl~by~je~mít~možnost nahlásit. Vývojář by~potom měl mít možnost tyto chyby sledovat a~opravit~je.

            Podobný je~i~případ požadavků na~nové funkce. Uživatel by~měl mít~možnost požádat o~novou funkci nebo zlepšení stávajících,
            aby~vývojář mohl aplikaci dále rozvíjet.

            \subsubsection{Běhové a kompilační chyby}
            Kompilace je~proces překladu zdrojového kódu do~binárního souboru, který je~přímo spustitelný na~procesoru.
            Při kompilaci se~kontroluje správnost kódu, datových typů ap. Případné chyby překladač oznámí vývojáři.
            Některé chyby může překladač opravit automaticky a~podle závažnosti chyby a~námi zavedených parametrů pro~překlad
            překlad proběhne v~pořádku nebo se~zastaví a~je~potřeba chyby nejdříve opravit.

            Chyby se~ale mohou projevit až~při~běhu programu. To~jsou chyby, které např.~závisí na~datech, která se~do~programu načítají.
            Příkladem takové chyby může být špatná práce s~pamětí, která může vést k~přetečení paměti a~následnému pádu programu.

            Na běhových chybách se~docela často zakládají útoky na~aplikace. Útočník může záměrně zasílat data, která způsobí chybu v~aplikaci,
            čímž může získat přístup k~systému nebo získat data, ke~kterým by~jinak přístup neměl.

            Důležité pro opravu chyb je~uvědomit si~jejich příčinu. To~je~často složité, protože chyba se~může projevit až~po~několika krocích nebo pouze za~specifického stavu aplikace.

            Proto je~nutné aplikaci testovat a~opravovat chyby, které se~vyskytnou. To~je~důležitá část vývoje aplikace. Důležité je~také sledovat
            chyby, které se~vyskytnou uživatelům. Jeden z~nástrojů, které to~umožňují, je~Sentry.

            \subsubsection{Sentry}
            Sentry je~nástroj, který umožňuje sledovat chyby za~běhu aplikace.
            Pomocí webového rozhrání potom může vývojář (nebo jeho tým) sledovat chyby, které se~vyskytly za~chodu~aplikace.
            Sentry umožňuje sledovat chyby v~různých jazycích, jako v~našem případě \textsc{Javascript a Go}. Ale i~v~dalších.


            V~každém z~těchto jazyků umožní \textsc{Sentry} sledovat chyby specifické pro~daný jazyk a~tím zjednodušit opravu chyb.
            Např.~v~případě \textsc{Javascriptu} umožní sledovat akce, které uživatel provedl, před tím, než došlo k~chybě. 
            Toho využiji pro~sledování chyb v~backendu i~frontendu aplikace.

            Díky tomu má~vývojář k~dispozici spoustu informací, které potřebuje k~nalezení, vyvolání a~opravě chyby.
            Sentry také umožňuje přímo vytvářet \textsc{úkoly}, na kterých mohou vývojáři pracovat.
            To~umožňuje vývojářům efektivněji rozdělovat práci na~opravách chyb, které Sentry zachytí.

            Informace navíc zůstanou uloženy v~Sentry a vývojáři se~k~nim mohou kdykoliv vrátit.
            Sentry je možno integrovat do~různých nástrojů, jako např.~Slack, který se~běžně používá ke~komunikaci v~týmech
            a~upomínka na~chybu se~objeví přímo v~komunikačním kanálu týmu.
	
        \subsection{Verzovací systém GIT}
        \textbf{GIT} vytvořil autor Linuxu \textbf{Linus Torvalds} v~roce 2005. Je~to~distribuovaný verzovací systém. To znamená, že~každý vývojář má~lokální kopii celého projektu, tedy může pracovat i~bez~připojení k~internetu a~následně své~změny nahrát na~server, když se~připojí.
        
        Základní funkcí \textsc{GITu} je~ukládání změn. Neukládáme celé soubory, ale pouze změny, které se~udály. Díky tomu je~možné spravovat i~velké projekty s~více vývojáři a~po~dokončení části práce vidět, co~který vývojář udělal a~spojit do~jednoho celku, na~kterém se~dále pracuje. Díky verzování je~také možné se~kdykoliv vrátit k~předchozí verzi projektu a~pokračovat ve~vývoji od~této verze nebo~pracovat na~několika různých verzích zároveň díky větvím.
        
        To~umožňuje vývojářům pracovat na~různých problémech projektu paralelně a~následně je~sloučit do~jednoho celku.

        Výslednou práci můžeme označit pomocí tagů, které se~používají pro~označení oficiálních vydání aplikace.

        Existují taky různé služby, které poskytují prostor pro~ukládání projektů online, tak~aby~byly zálohované a~přístupné odkudkoliv, jako např.~\textbf{GitHub}, \textbf{GitLab} nebo~\textbf{Bitbucket}. Mimo zmíněné funkce nabízejí třeba možnost vytvářet \textsc{Issues}, které může vývojář vytvořit, pokud narazí na~chybu nebo~má~nápad na~vylepšení. Tímto způsobem může vývojáři sdělit svůj nápad nebo~chybu a~případně se~k~ním vrátit později. \textsc{Issues} je~také možné přiřadit konkrétnímu vývojáři, který se~o~danou chybu nebo~nápad postará, a~automaticky vytvořit větev, na~které bude práce probíhat. Na konci práce vývojář vytvoří tzv.~\textbf{Merge Request}, kde oznámi, jak problém řešil, a požádá o~sloučení nového kódu do~hlavní větve projektu. Je~taky možné jednoduše zobrazit rozdíly mezi hlavní větví a~tou, na~které vývojář pracuje.
        
        \textbf{GIT} je~pro~vývoj dnešních aplikací nepostradatelný nástroj \parencite{gitscmBook}.
        
        \textbf{Gitlab} je open-source nástroj pro~správu verzí na~serveru. Je~možné jej~zdarma nainstalovat na~vlastní server a~mít~tak~plnou kontrolu nad~svými daty. Nabízí také možnost vytvářet \textsc{Issues}, \textsc{Merge Requesty} a~další funkce. Je~možné jej~nainstalovat na~vlastní server a~mít~tak~plnou kontrolu nad~svými daty, což~využívá spousta společností, které mají např.~více projektů.

        \subsection{Linux a příkazová řádka, WSL2}
        Linux je~operační systém, který vytvořil Linus Torvalds v~roce 1991. Je~to~nejrozšířenější open source operační systém,
        používaný zejména na~serverech. Je~to~také základ pro~mnoho dalších operačních systémů, jako např.~Android.
        
        Velikou výhodou je otevřenost a~možnost upravovat zdrojový kód. To~umožňuje vývojářům upravovat systém podle svých potřeb.
        Další výhodou je~jeho bezpečnost a~svoboda. V~porovnání s~ostatními operačními systémy je~mnohem bezpečnější a~méně náchylný k~virům.

        Nabízí mnoho grafických prostředí, takže si~uživatel může vybrat, jakým způsobem bude systém používat a je možné téměř
        všechno nastavit tak, jak v práci potřebuje.

        Navíc většina nástrojů pro vývoj webových aplikací je~vyvíjena pro~Linux, takže je~možné je~používat bez~problémů a~automaticky vše nastavit skriptem z~příkazové řádky. Není nutné instalovat a~mít~spuštěno 5 různých nástrojových oken, vše je~na~jednom místě.

        Na Windows je možné Linux využívat pomocí \textbf{WSL2 (Windows Subsystem for Linux)}. Jedná se~o~virtuální stroj, který běží na~pozadí a umožní uživateli Windows používat výhody, které nabízí Linux, např.~má~vývojové nástroje na~jednom místě, místo několika oken, které musí mít při vývoji na Windows.

	\section{Návrh aplikace}
        Před samotným vývojem aplikace je~potřeba se~zamyslet, jak bude aplikace fungovat, jaké bude mít funkce a~jak bude vypadat. Tvoříme tak tzv.~\textsc{funkční požadavky} na~výslednou aplikaci. Potom můžeme vytvořit \textsc{UML modely}, které mohou pomoct blíže si~promyslet strukturu a~uvědomit si~některé další aspekty vývoje, které nás~mohou potkat.

        Na~začátku plánování projektu je~dobré se~zamyslet i~nad~tím, jaké technologie budeme používat, jak budou jednotlivé součásti komunikovat a~jakým způsobem budeme aplikaci vyvíjet \parencite{bctynovsky:specifikacepozadavku}.
    
        V~profesionálním prostředí je~potom důležité přemýšlet i~nad~tím, jestli budeme aplikaci vyvíjet sami nebo~v~týmu a~zda je~na~trhu práce dostatek lidí, kteří dané technologie znají.

        \subsection{Účel a~popis fungování vyvíjené aplikace}
        Aplikace \textsc{Písemkomat}, poskytne registrovaným uživatelům možnost vytvořit vytvořit si příklady, umístěné ve~volitelně
        strukturovaných kategorií - podle předmětu, ročníku, tématu... Tyto příklady bude možné následně využít při tvorbě písemných prací,
        kde~bude mít~uživatel možnost zvolit kategorie, ze~kterých se~příklady vyberou, a~počet příkladů, které se~mají do~písemky vygenerovat. 
        \subsection{Příklad použití}
        Učitel chce vytvořit 2~verze písemky s~rozdílnými příklady pro~své žáky.
        
        Zaregistruje~se do~aplikace \textsc{Písemkomat} a~přihlásí se~do~svého účtu. Jde~o~učitele matematiky, takže si~vytvoří 5~příkladů z~tohoto předmětu a~vloží je do kategorie Matematika.

        Následně si~vytvoří písemnou práci a~může si~vybrat, zda~chce, aby~se~v~jeho písemce objevily všechny příklady, nebo jen některé. Bude tedy chtít použít 3\,příklady s~náhodně dosazenými nebo~dopočítanými hodnotami.
        
        Některé hodnoty nemohou být zcela náhodné, protože by~to mohlo vést k~neřešitelným příkladům, nebo příkladům s~nulovým výsledkem.
        Proto \textsc{Písemkomat} umožní vytvořit si~proměnné, které budou mít~přiřazenou náhodnou hodnotu z~určitého intervalu nebo vypočtené z~jiných proměnných.

        Učitel si~např.~vytvoří proměnné $A, B, C$ a $D$, kde $A, B$ budou náhodná čísla od~1 do~10, $C = 4/3*A$ a $D = C + B$.

        Řešený příklad se~vygeneruje do~vzorce, který potom zapíše do~\textsc{Písemkomatu}. Do~proměnných $A, B$ se~uloží náhodné číslo z~intervalu, který~si~učitel nastavil a~pomocí zápisu proměnné \texttt{\$\{A\}} se~vloží do~příkladu na~zadané místo, resp.~do zápisu výpočtu dalších proměnných, kde budou použity ve výpočtu.
        
        Tedy předpokládejme, že~budou vygenerována náhodná čísla $A = 3$ a~$B = 5$
        a~hodnoty proměnných $C, D$ jsou~zadány takto:
        \begin{align*}
            \$A &= 3 \\
            \$B &= 5 \\
            \$C &= 4/3*\$A = 4/3*3 = 4 \\
            \$D &= \$C + \$B = 4 + 5 = 9
        \end{align*}

        Proměnné se~při~generování výsledné podoby příkladu nahradí vygenerovanými čísly nebo výrazy.
        
        Zároveň bude možné je~nastavit tak, aby hodnoty nevyčíslovaly. Proměnné budou také moci nést jiné objekty, např.~pole pro~textový vstup nebo výběr z~možností. Toho bude možné využít při~tvorbě zadání, kde~bude~více vstupních polí, která bude mít~za~úkol žák vyplnit.

        Výsledná podoba příkladu jednoduchého výrazu může vypadat např.~takto:
        \begin{align*}
            \text{Vyřeš v oboru N:} \quad \$Ax + \$B &= \$C + \$D \\
            \begin{aligned}
                a) \quad &\text{Nemá řešení v oboru N} \\
                b) \quad &\text{x = \$A} \\
                c) \quad &\text{x = \$B} \\
                d) \quad &\text{x = \$\{\$A * \$B - 2\}} \\
            \end{aligned}
        \end{align*}

        Proměnné bude možné shlukovat do~variant. To~umožní vytvořit více variant příkladů. Např.~varianta, kde~se~budou generovat čísla celá a~varianta, kde~se~budou vyskytovat i~zlomky. Učitel si~pak~při~tvorbě písemky jen vybere, kterou variantu chce použít.

        Učitel bude mít také možnost zvolit~si, jestli chce otevřenou nebo uzavřenou formu příkladu s~možnostmi výběru. V~tomto případě může taky využít proměnné, které si~vytvořil dříve. V~obou případech může taky zapsat vzorec, ze~kterého se~vypočtou možnosti a~označit správnou možnost. Pokud učitel pro tvorbu možnosti využije vzorec, bude možné jich z~jedné možnosti vytvořit několik. Ve~výsledném příkladu se~v~možnostech výběru proměnné nahradí a~výraz se~vyčíslí, pokud nebude přepínači určeno jinak.

        Výsledná podoba zadání a~možností příkladu může vypadat např.~takto:
        \begin{align*}
            \text{Vyřeš v oboru N:} \quad 3x + 5 = 4 + 9 \\
            \begin{aligned}
                a) \quad &\text{Nemá řešení v oboru N} \\
                b) \quad &\text{x = 3} \\
                c) \quad &\text{x = 4} \\
                d) \quad &\text{x = 13} \\
            \end{aligned}
        \end{align*}

        Vstupní políčka se~ve~výsledné práci vykreslí jako prázdné nebo podtržené místo o~velikosti určené při~zadávání proměnné. Nebo v~případě možnosti výběru se~na~místě vykreslí všechny možnosti, aby~žák mohl vybrat správnou možnost kroužkováním nebo tak, jak učitel určí.
        
        To umožní systém používat např.~pro jazykové předměty, kde se~využívá doplňování slov do~textu nebo~výběr písmene.

        Některá nastavení bude možné ovlivnit (vypínat, zapínat, měnit velikosti) i~na úrovni celých písemek. Pokročilý uživatel potom bude mít možnost vytvořit si~vlastní šablony pro výpis příkladu.

        \subsection{UML - Unified Modeling Language}
        Jeden ze~standardních nástrojů pro~modelování aplikace je~\textsc{UML}. \textsc{UML} je~standardizovaný grafický jazyk pro~modelování softwarových systémů. První verze byla vydána v~roce 1997 a~od~té~doby se~stala standardem pro~modelování softwarových systémů.
        Základem \textsc{UML} je~\textbf{UML diagram}, který slouží k~vizualizaci návrhu aplikace. \parencite{uml:diagram}
        
        Specifikace definuje základní dva typy diagramů:
        \begin{itemize}
            \item \textbf{Strukturální diagramy} - popisují strukturu systému, tedy jeho části a~vztahy mezi nimi. Může jít např.~o~diagramy tříd, objektů, komponent, nebo~komunikace mezi~komponentami\dots
            \item \textbf{Diagramy chování} - popisují chování systému, tedy jak se~jeho části chovají a~jak spolu komunikují. Např.~diagramy aktivit, stavový diagram, nebo~diagram případů užití\dots
        \end{itemize}

        Pro naplánování své práce jsem si~vybral diagramy ze~standardu \textsc{UML}\,--\,diagram případů užití \textsc{Use Case Diagram} a~diagram~vztahů mezi~třídami \textsc{Class Diagram}.

        \subsection{UCD - Use Case Diagram}
        \textsc{UCD} je~diagram ze~standardu \textsc{UML}, který popisuje chování systému z~pohledu uživatele. Jednotlivým aktérům jsou přiřazeny případy užití, které popisují, jaké akce může aktér systém používat.

        To nám může pomoct při~přípravě zjistit,  jaké funkce bude aplikace mít a~tím nastínit, jaké bude potřeba vytvořit \textsc{Endpointy} v~\textsc{API}.
        Taky si~můžeme ověřit správnost návrhu a~zjistit, zda~jsme nějakou funkcionalitu nevynechali, protože na~diagramu jsou případné nedostatky vidět lépe.
        
        A hlavně nám to~umožní lépe si~představit, jak bude aplikace fungovat, jaké funkce bude mít a~jaké \textsc{endpointy} budeme potřebovat vytvořit, aby~bylo možné akce provádět. \parencite{uml:usecase}

        Při~modelování pomocí \textsc{UCD} se~používají symboly, které znázorňují jednotlivé části diagramu.
        \begin{itemize}
            \item \textbf{Aktér} je~osoba nebo systém, který používá aplikaci. Aktérem může být např.~uživatel, čas nebo~jiná aplikace. K~označení se~používají ikony lidí a~textový popisek.
            \item \textbf{Případ užití} je~akce, kterou aplikace \textsc{aktérovi} nabízí. Případ užití je~zobrazen jako elipsa, která je~připojena k~aktérovi čarou.
            \item \textbf{Vztahy mezi~aktéry a~případy užití} znázorňují, jestli a~jakým způsobem může aktér případ užití používat. Vztahy se~značí šipkami, které vycházejí z~aktéra a~končí u~případu užití.
            \item \textbf{Rozšíření} (extend) - je~případ užití, který přejímá vlastnosti předchozího případu užití a~rozšiřuje je~o~další možnosti. Znázorňuje se~jako šipka, která míří směrem z~případu užití a~končí u~případu užití, který rozšiřuje.
            \item \textbf{Zahrnutí} (include)- zahrnutí je~případ užití, který je~součástí jiného případu užití. Znázorňuje se~jako šipka, která vychází z~případu užití, který zahrnuje a~končí u~případu užití, který je~zahrnut.
        \end{itemize}

        \subsection{Class Diagram}
        \textsc{Class diagram} (\textsc{Diagram tříd}) je~také součástí~standardu \textsc{UML}. Zobrazuje třídy, jejich atributy a~metody a~vztahy mezi~nimi.

        \textbf{Vlastnost (atribut) třídy} je~proměnná, která je~přiřazena k~třídě. Nese vlastnost, která dává~v~kontextu třídy smysl. Např.~třída \texttt{Auto} může mít~vlastnost \texttt{barva}, která bude mít~hodnotu \texttt{červená} a~vlastnost \texttt{maxSpeed}, která bude mít~hodnotu \texttt{200 km/h}.

        \textbf{Metoda třídy} je~funkce, která je~přiřazena k~třídě. Může mít~parametry a~výstupní hodnotu. Např.~třída \texttt{Auto} může mít~metodu \texttt{drive}, která bude mít~parametr \texttt{speed} k~určení, jakou rychlostí má~auto jet.
        
        Třída je v~diagramu~tříd zobrazena jako obdélník rozdělený na tři části. V~první části je~název třídy, ve~druhé jsou vlastnosti a~ve~třetí metody. \textbf{Veřejné} vlastnosti a~metody mají na~začátku názvu \texttt{+}, \textbf{chráněné} \texttt{\#}, \textbf{privátní} \texttt{-} a~\textbf{statické} \texttt{\_}.
        
        \textbf{Veřejné (public)} vlastnosti a~metody jsou přístupné ostatním třídám a~komukoliv, kdo~má~přístup k~objektu je~může zobrazit či~změnit. Vlastnosti a~metody mají na~začátku názvu \texttt{+}.

        \textbf{Chráněné (protected)} vlastnosti a~metody jsou přístupné jen třídám, které dědí vlastnosti z~třídy, ze~které dědí. Na~začátku názvu píšeme~\texttt{\#}.
        
        \textbf{Privátní (private)} vlastnosti a~metody jsou přístupné jen třídě, ve~které jsou definovány a~nikdo jiný s~nimi nemůže pracovat. Na~začátku názvu píšeme~\texttt{-}.
        
        \textbf{Statické (static)} jsou vlastnosti a~metody, které jsou společné pro~všechny instance třídy a~tedy nejsou přidružené žádnému objektu a~lze~je~používat i~bez inicializace objektu. Označujeme znakem \texttt{\textunderscore}.
        
        Vztahy inkluze a~rozšíření jsou v diagramu tříd zobrazeny stejně jako u~\textsc{UCD} \parencite{visualparadigmClassDiagram}.

        \subsection{Návrh struktury databáze}
        Pro~ukládání dat v~aplikaci použijeme databázi. Databáze je~soubor dat, která jsou~uspořádána tak, aby~byla snadno vyhledatelná a~měla nějaký význam.

        Při~plánování budeme kromě ERD~společně s~UC diagramem plánovat konkrétní tabulky a~vztahy mezi~nimi. UC~diagram nám pomůže zjistit, jaké SQL~dotazy nejspíše budeme potřebovat, což nám umožní lepší náhled, které sloupce budeme indexovat pro~optimální dotazy.
        Pak můžeme s~ERD zkonzultovat, jaké budeme potřebovat definovat cizí klíče.

        Potom již můžeme začít vytvářet SQL dotazy k~vytvoření tabulek. Používáme k~tomu jazyk \textsc{SQL} (Structured Query Language), kterým ovládáme naši MySQL (MariaDB) databázi.

        \subsection{Výběr technologií}
            Výběr technologií je~důležitý krok. Je nutné vybírat efektivní technologie, které budou dostatečně výkonné a~zároveň budou
            přívětivé pro vývojáře, aby vývoj nebyl zbytečně časově náročný. Je~dobré také myslet na~budoucí podporu a~rozšiřitelnost aplikace.

            \textbf{React} použiju pro tvorbu \textsc{Frontendu}. Umožní mi efektivní tvorbu uživatelského rozhrání, (\textsc{User Interface, UI}).

            \textbf{Typescript} samozřejmě použijeme i~při vývoji aplikace v~Reactu. \textsc{Facebook} s~tím~samozřejmě počítá a~vydává
            kromě Reactu také balíček s~příslušnými datovými typy, pro použití v~Typescriptu. Typescript podporuje i~použití JSX šablon. \parencite[Refeerence/Handbook/JSX]{TypeScript}

            \textbf{MathJax} je~knihovna, která umožňuje zobrazovat matematické vzorce na~webových stránkách.
            Přijímá formáty matematiky zapsané ve~formátu, který používá systém \LaTeX. Ten~se poté převádí do~vizuální podoby, sestavené z~HTML prvků, kterou může prohlížeč zobrazit.
            
            MathJax nabízí i~možnost zobrazení ve~formě vektorové grafiky ve~formátu SVG.
            Díky tomu můžeme v~aplikaci názorně vykreslovat matematické vzorce, které se~vyskytnou v~příkladech nebo~učebních materiálech.\parencite{abclinuxuMatematickxE9Vzorce}

            \LaTeX je~profesionální nástroj pro~sazbu textů s~možnostmi matematických vzorců, který je~používán zejména v~akademickém prostředí.\parencite{Rybicka2003:latex}

            \textbf{Go} je~staticky typovaný, kompilovaný jazyk vyvinutý společností Google v~roce 2007. Je to~jazyk, který je~velice rychlý a~jednoduchý na~psaní.

            Protože je~kompilovaný, je~rychlý i~při~běhu programu. Je~to~jazyk, který je~velice oblíbený pro~tvorbu webových aplikací. Umožňuje při~vývoji jednoduše importovat existující balíčky z~GIT repozitářů nebo i~jiných zdrojů a~používat je~v~aplikaci a~sám si~tyto balíčky stáhne a~nainstaluje. Tím~značně urychluje vývoj aplikace.

            Zároveň při kompilaci vzniká jeden binární soubor, takže přestože je aplikace docela rozsáhlá, je~dostatečně rychlá.

            Základní funkce webových frameworků obecně je~tzv.~\textsc{Router}, který umožňuje definovat jednotlivé \textsc{koncové body} (\textbf{endpointy}) a~typy požadavků, které můžeme využít pro~komunikaci s~nimi.
            
            Když~do~aplikace přijde požadavek, \textsc{Router} zkontroluje, zda~existuje \textsc{koncový bod}, který odpovídá požadavku a~pokud ano, předá požadavek příslušné \textsc{Obslužné rutině} (\textbf{handler}u).

            Každý \textsc{koncový bod} má~svou~vlastní \textsc{Obslužnou rutinu} (dále \textbf{handler}), která zpracuje požadavek a~vrátí odpověď.
            Gin také umožňuje vytvářet skupiny \textsc{koncových bodů}, které mají společný základ~URL adresy a které mohou mít společný \textsc{handler}.
            To~umožňuje vytvářet aplikace, které mají jednotnou strukturu a~jsou přehledné. Např.~všechny \textsc{koncové body} pro~přihlášené
            uživatele můžeme předem definovat a~zabezpečit.
            
            \textbf{MySQL} je~relační databáze, která je~dnes jednou z~nejpoužívanějších databází. Je~dostatečně rychlá a~spolehlivá. \parencite{databases21}
            MySQL~je~\textsc{relační databáze}. Ukládá data v~databázích a~tabulkách, kde~jednotlivé sloupce určují typ dat a~jejich název. Každý řádek je~záznamem v~dané tabulce.
            
            Jednotlivé databáze - někdy používáme název \textsc{schéma} - fyzicky na~disku reprezentují adresáře s~názvem konkrétní databáze. Jednotlivé~tabulky potom tvoří binární soubory s~příponou podle databázového \textsc{enginu}, který používáme. V~našem případě používáme \textsc{InnoDB}, který ukládá strukturu a~data v~souborech \textsc{*.ibd}. \parencite{MySQLInnoDB}
            
            \textbf{GORM} je~ORM (ORM - Object-relational mapper) pro~jazyk Go. \textsc{ORM} systémy umožňují jednoduše vytvářet databázové modely z~definovaných struktur. 
            Z~definovaných~struktur se~automaticky vytvoří všechny databázové tabulky a~při jejich změnách se~automaticky promítnou i~do~databáze během tzv.~migrace modelů.
            Struktury zároveň umožňují jednodušší kontrolu nad~daty, která se~do~databáze ukládají a~zjednodušují nám načítání konkrétních dat. \parencite{freecodecamp:orm}

            Pokud je~potřeba nějaké složitější operace, samozřejmě je~možné využít i~samostatně formulované SQL dotazy. \parencite{gormGORM}

            \textbf{Vite} je~nový nástroj pro~vytváření \textsc{Frontendu}. Je~to~nástroj, který je~velice rychlý a~jednoduchý na~použití.

            \textbf{Docker, docker-compose} jsou nástroje, které umožňují vytvářet kontejnery, ve~kterých můžeme spouštět aplikace.
            Použití kontejnerů při vývoji je~výhodné, protože vždy, když si~projekt znovu stáhneme, máme jistotu, že~aplikace běží
            ve~stejném prostředí, jako kdekoliv jinde. To~umožňuje jednodušší vývoj a~nasazení aplikace.

            Taky nám to~umožní rychle vytvořit kontejnery s~potřebnými službami, jako třeba databázi, na~jakékoliv platformě. Navíc je~kontejner přístupný pouze použitím specifického portu,
            čímž se~snižuje riziko útoku na~server, na~kterém aplikace běží. \parencite{docker}

            Na~serveru navíc lze provozovat více kontejnerů, dostupných na~různých portech, což umožňuje provozovat více aplikací na~jednom serveru.

            \textbf{Nginx} se~sám~definuje jako webový server a~reverzní proxy server a~load balancer.

            \textsc{Reverzní server} umožňuje přesměrovat požadavky na~různé servery, resp.~aplikace (porty), podle zadaných pravidel. Třeba podle URL adresy, typu požadovaného souboru nebo typu požadavku.
            
            \textsc{Load balancer} umožňuje rozdělovat zátěž mezi servery (resp.~aplikacemi), které má~k~dispozici. To~se~využívá u~větších aplikací, které mají vysokou používanost nebo v~případě že~jednotlivé součásti aplikace běží na~více serverech. To~může nastat třeba v~případě externí služby pro~účely části aplikace nebo nastavení záložních serverů, které se~použijí v~případě, že~bude hlavní server přetížený či~nedostupný.
            
            \textsc{Nginx} je~považován za~velmi rychlý ve~srovnání s~jinými servery, jako např.~Apache. Zejména pak při obsluze statických souborů. Je~napsán v~jazyce C a~je~dostupný pro~většinu operačních systémů. Vydaná  \parencite{WhatNGINX}

            A~nakonec \textbf{Alpine Linux}, který je~odlehčenou distribucí Linuxu, která je~určena pro~nasazení v~kontejnerech, nicméně je~možné ji~použít i~na~serveru. Celková velikost distribuce je~pouze 5~MB, což je~velice málo. 

            Tuto distribuci používám jako hlavní systém na~svém VPS\footnote{VPS - Virtual Private Server}.
            Na~serveru poběží pouze \textbf{Nginx}, který nasměruje požadavky na~správné porty, a \textbf{Firewall} (\textbf{UFW}), který zablokuje přístup k~neveřejným portům.

            \textbf{Docker} resp. \textbf{Docker-compose} bude spouštět kontejnery s~aplikací (Vite~i~Go) a~databází
            kromě těch, které jsou potřeba pro chod aplikace.

            Tím bych chtěl dosáhnout maximálního poměru výkonu a~bezpečnosti.
	
	\section{Postup implementace}
        Nejprve je~potřeba vytvořit základní strukturu aplikace. Rozhodl jsem~se, že~pro lepší automatizaci budou vývojové i~produkční prostředí tvořit \textsc{Docker kontejnery}.
        Vývojová verze bude obsahovat kontejnery pro~React, Go s~databází. Navíc bude obsahovat nástroj \textsc{Air}, který umožní automatický restart aplikace při~změně kódu \textsc{backendu}. Taky využijeme proxy přesměrování nástroje Vite, který přesměruje požadavky na~backend na~správný kontejner.

        Produkční verze, tedy ta~výsledná, bude obsahovat stejné kontejnery, ale nebude už~obsahovat nástroje pro~vývoj. Při tvorbě kontejnerů se~backend zkompiluje a~spustí se~pouze optimalizovaný binární soubor.
        Přesměrování na~kontejnery zajistí server \textsc{Nginx}, který běží v~prostředí VPS serveru a~obsluhuje i~další aplikace.

        Každý kontejner bude mít vlastní adresář. Backend bude v~adresáři `goapp` a frontend v~adresáři `reactapp`. Všechny kontejnery budou mít společné úložiště adresář `data`, kde si~vytvoří podadresáře. Data budou ukládat do~sdílených adresářů, aby~se~při~restartu kontejneru neztratila.

        Konfigurace a~pokyny pro~vytvoření kontejnerů budou v~adresáři `docker` a~v~souborech \textsc{docker-compose.yml} v~kořenovém adresáři. K~dispozici budou dvě verze, \textbf{vývojová} bude připravena pro~vývoj na~lokálním počítači a~optimalizovaná, tzv.~\textbf{produkční} pro~nasazení na~server.

        K~tomu bude dostupný soubor \texttt{Makefile}, který umožní rychleji spouštět příkazy pro~vytvoření kontejnerů a~dalších operací.

        Celý základ aplikace je~pro~další vývojáře veřejně dostupný na~mém Gitlabu: \href{https://gitlab.com/sjiamnocna/gormrest}{\textbf{sjiamnocna/gormrest}}. Tento základ mohou vývojáři použít k~tvorbě nových aplikací.
        
        \subsection{Backend}
            V aplikaci používám pro~tvorbu backendu jazyk \textbf{Go}, který bude zpracovávat požadavky od~klienta a~komunikovat s~databází.
            Protože je~dobrou praxí rozdělit kód na~více funkčních celků, budu využívat \textsc{moduly}. Moduly umožňují mimo jiné další využití v~jiných projektech a~pokud použijeme nějaké obecné moduly, spravované jiným týmem (pokud to dovoluje zadání od~zákazníka i~licence využívaného modulu), ušetříme vývojem podobného modulu spoustu času. \parencite{Zimmerman2023:howtowritebetter}
            Pro~obsluhu požadavků na~backend budu využívat \href{https://github.com/gin-gonic/gin}{\textbf{gin-gonic/gin}} s~vlastním dříve~vytvořeným rozšířením o~kontrolu~a~správu \textsc{JWT} tokenu \href{https://gitlab.com/sjiamnocna/goethe}{\textbf{sjiamnocna/goethe}}. Ten zároveň přidává základní \textsc{endpointy} pro~autentikaci požadavků.
            Při~vývoji také využiju balíček \href{https://github.com/cosmtrek/air}{\textbf{cosmtrek/Air}}, který umožňuje automaticky restartovat aplikaci při~každé změně kódu, čímž bude možné vývoj aplikace trochu zjednodušit a~zbavit se~nutnosti manuální kompilace a~restartování backendové aplikace.

            Samotný \textsc{backend} bude tvořen dvěma částmi, aby~byl~lépe testovatelný a~rozšiřitelný. Půjde o~\textsc{webový server}, který bude přijímat požadavky a~spravovat uživatelská data, a~\textsc{generátor}, který přijme požadavky na~příklad a~vygeneruje výsledné zadání, nebo sdělí chyby v~případě, že~nějaké nastanou.
            
            \subsubsection{Funkce Init}
            \textbf{Go} má~dvě vstupní funkce \textbf{main} a~\textbf{init}. Funkce \textbf{main} je~hlavní vstupní bod aplikace, který se~spustí jako první. Funkce \textbf{init} se~spustí jako první, ale~před funkcí \textbf{main} a~slouží k~načtení konfigurací z~prostředí nebo připojení se~do~databáze. Funkce \textbf{main} je~hlavní funkcí aplikace, kde~se nachází logika aplikace.

            Ve~chvíli, kdy spustíme aplikaci, se~nejdříve spustí funkce \textbf{init} a~poté hlavní část aplikace, funkce \textbf{main}. Je~to~podobné jako v~jazyce C a~dalších kompilovaných jazycích, nebo při psaní kódu pro \textsc{Arduino}, kde se~automaticky spouští hlavní funkce \textbf{loop}, řídí logiku výstupních pinů a~dalších částí programu.
            
            Ve~funkci~\textsc{init} se~pomocí \textsc{systému GORM} (\href{https://gorm.io/}{\textbf{go-gorm/gorm}}), připojíme k~databázi, aby mohl spravovat tabulky a~modely dat pro~manipulaci s~nimi. ORM automaticky ukládá data do~databáze a~při~změně modelů je~schopen automaticky migrovat databázi, což výrazně zjednoduší vývoj aplikace.

            K~připojení do~databáze tedy budu potřebovat tzv.~\textsc{DSN} (Data Source Name). Je~to~řetezec znaků který obsahuje informace o~připojení do~databáze. Potřebujeme \textbf{adresu} databáze a~\textbf{port}, na~kterém běží, \textbf{název databáze}, \textbf{jméno uživatele} a~\textbf{heslo}. Ty~si~načítám z~prostředí systému, tedy \textsc{Dockeru}. Takto vytvořené spojení předám do \textbf{GORM}

            Ve~funkci \texttt{init} také spustím migraci databáze, kde \textsc{GORM} vytvoří tabulky nebo je~aktualizuje.


            \subsubsection{Funkce Main}
            V~hlavní funkci spouštíme hlavní logiku aplikace. Je~potřeba spustit \textsc{HTTP server}, který bude čekat na~požadavky od~klienta na~definovaném portu. K~tomu využijeme funkci \textbf{Run} z~balíčku \textbf{gin-gonic/gin}, prostřednictvím balíčku \href{https://gitlab.com/sjiamnocna/goethe}{\textbf{sjiamnocna/goethe}}, který přidá do~serveru tzv.~\textsc{middleware} pro~udržování a~kontrolu \textsc{JWT} tokenu a~přidá do~každého požadavku informace o~uživateli, který požadavek poslal. \textsc{Middleware}, je~funkce, která se~spustí před zpracováním požadavku a~může měnit jeho chování. V~tomto případě kontroluje, zda~je~požadavek autentický, případně zda jsou data autentická (nezměněná) a~zda~je~přihlášen nějaký uživatel. Tyto~informace pak~uloží do~požadavku, aby~s~nimi mohly pracovat handlery. Serveru tím říkáme, aby přijímal a~obsluhoval požadavky na~zadaném portu.
            
            % TODO: GORM Modely

            Samotné \textsc{Endpointy} budou umístěny v~adresáři \textsc{Endpoints}, kde~každý \textsc{Endpoint} bude mít svůj vlastní soubor. V~těchto souborech budou handlery pro~každý potřebný \textsc{Endpoint}. \textsc{Handler} dostane jako parametr \textbf{gin.Context}, který obsahuje kontext aktuálního požadavku a~umožňuje s~ním pracovat, a~budou odpovídat spefickou \textbf{JSON} odpověďí, případně chybovou hlášku.

        \subsection{Frontend}
            \textbf{Frontend} bude vytvořen pomocí nástroje \textbf{Vite} v~jazyce \textbf{Typescript} s~použitím knihovny \textbf{React}. Pro~komunikaci s~backendem využiju dříve napsaný \emph{Typescript} modul \href{https://gitlab.com/sjiamnocna/renette-api}{\textbf{sjiamnocna/renette-api}:main}, který je~napsaný k~jednodušší komunikaci frontendu s~\href{https://gitlab.com/sjiamnocna/goethe}{\textbf{sjiamnocna/goethe}}.
        \subsection{Testování}
        \subsection{Údržba}
        
	\section{Budoucí rozvoj aplikace}
        Pro rozvoj aplikace bude nutné sledovat použití aplikace a~případné chyby, které se~vyskytnou v~\emph{sentry} nebo nám~je~nahlásí uživatelé, a~opravovat je.
        Bylo by dobré, kdyby aplikaci učitelé používali a~sdíleli mezi sebou příklady. Tím se~budou moci více věnovat svým žákům. Postupně by~tak mohla vzniknout databáze příkladů, které by~mohli využít ostatní učitelé a~žáci k~procvičování příkladů.
        Do~budoucna bych chtěl vývoj rozšířit o~další vývojáře, kteří by~se~podíleli na~vývoji a~rozšiřování aplikace. V~plánu je~také přidat možnost ověření uživatele pomocí ITIC/ISIC, čímž by~se~zvýšila důvěryhodnost uživatelů.
        
        Existuje mnoho dalších prostředí, která by~mohla využít aplikaci pro~tvorbu příkladů. Aplikace \textsc{Písemkomat} bude dostupná přes~\textsc{API}, mohla by~být integrována do~těchto prostředí formou pluginu a~učitelé by~mohli využívat generované příklady i~v~těchto prostředích.
        
        Mohly by~tak~vzniknout moduly pro~použití v~těchto prostředích, které by~umožňovaly vytvářet příklady a~zadávat je~žákům přímo v~Moodlu, Google Classroom nebo~je~rychle sdílet přes MS~Teams. Zajímavá by~mohla~být i~integrace do~\textsc{CMS} systému Wordpress.

        Učitelům by~mohla být~umožněna tvorba kampaní, kde by~žáci postupovali v~rámci kampaně a~otevírali nové schopnosti. Třeba sérii cvičení na~přijímací zkoušky na~konkrétní střední školu, nebo~soutěžní příklady.
        
        K~tomu se~nabízí rozšíření na~\uv{herní režim}, který by~umožňoval žákům soutěžit mezi sebou a~získávat body za~splněné příklady nebo posílat výzvy ostatním.

        Aplikace by~se~dala využít také~ke~tvorbě interaktivních výukových materiálů a~minikvízů, které by~mohly být využity pro~výuku na~dálku. Učitel by~mohl vytvořit výukový materiál, který by~žákům poslal a~ti~by~si~ho~mohli procházet. V~rámci materiálů by~mohly být~menší kvízové otázky, které poslouží k~procvičování učiva. Učitel by~pak~mohl získat zpětnou vazbu, jak si~žáci vedou a~které části učiva jim dělají největší problémy. K~rychlému zobrazení řešení by~pomohla možnost zadat příklad do~WolfRam Alpha. 
        
        Předchozí rozšíření vybízí k~využítí k~online výuce, kde by~učitel měl~k~dispozici živě přenášenou \uv{tabuli}, ideálně s~živým přepisem do~formátu \textsc{Markdown}u a~Mathjaxu.

        Pro~realizaci výše zmíněných rozšíření by~bylo vhodné získat sponzory, kteří by~přispěli k~vývoji aplikace, což~by~umožnilo věnovat se~vývoji aplikace naplno a~rychleji rozšiřovat její funkce.
	
	\section{Závěr}

    \newpage
    \printbibliography
\end{document}
